\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage[]{algorithm2e}
\usepackage{placeins}

\sloppy

\title{Análise de desempenho do algoritmo \textit{bucketsort} para diferentes subalgoritmos de ordenação}

\author{Eugenio Souza Carvalho\inst{1}, Hugo Santos Piauilino Neto\inst{1}}


\address{Departamento de Computação\\
	Universidade Federal do Piauí
	(UFPI)\\
	Teresina -- PI -- Brazil
	\email{\{eugeniucarvalho,hugos94\}@gmail.com}
}

\SetKwProg{Fn}{Function}{}{}

\begin{document} 

\maketitle

\begin{abstract}
	This work presents a performance analysis of \textit{bucketsort} algorithm for different sorting subalgorithms, in addition to a general overview of the history and operation of the algorithms.
\end{abstract}

\begin{resumo} 
	Este trabalho apresenta uma análise de desempenho do algoritmo de ordenação \textit{bucketsort} para diferentes subalgoritmos de ordenação, além de apresentar um resumo geral sobre a história e funcionamento dos algoritmos. 
\end{resumo}


\section{Introdução}

Problemas são questões propostas em busca de uma solução. Algoritmos são utilizados com o propósito de conceder uma solução para certo problema. Para todo problema decidível existe um algoritmo que determina uma solução para as instâncias desse problema.

Algoritmos descrevem passo a passo os procedimentos para chegar a uma solução de um problema e podem ser representados de três formas: descrição narrativa, fluxograma e a linguagem algorítmica. Neste trabalho focaremos na utilização da última forma.

Algoritmo de ordenação, em ciência da computação, é um algoritmo que coloca os elementos de uma dada sequência em uma certa ordem. Em outras palavras efetua sua ordenação completa ou parcial de acordo com uma necessidade pré-estabelecida. O objetivo da ordenação é facilitar a recuperação dos dados de uma lista.

Os mais populares algoritmos de ordenação são: \textit{insertionsort}, \textit{selectionsort}, \textit{bubblesort}, \textit{bucketsort}, \textit{quicksort}, \textit{mergesort}, \textit{heapsort} e \textit{shellsort}. Neste artigo, o algoritmo \textit{bucketsort} será analisado, explicando seu funcionamento, suas peculiaridades e seu comportamento quando os subalgoritmos \textit{insertionsort}, \textit{mergesort}, \textit{heapsort} e \textit{quicksort} são utilizados.

\section{\textit{Bucketsort}}

O \textit{bucketsort} ou algoritmo de ordenação por baldes, funciona em tempo linear quando a entrada é gerada a partir de uma distribuição uniforme. O \textit{bucketsort} é rápido porque pressupõe  que a entrada é gerada por um processo aleatório que distribui elementos uniformemente sobre o intervalo $[0,1)$  \cite{cormen}.

O algoritmo \textit{bucketsort} originou-se do método \textit{countingsort} (ordenação por contagem), pois o \textit{bucketsort} torna-se \textit{countingsort} quando os baldes possuem tamanho 1. O \textit{countingsort} funciona separando cada número do \textit{array} original e colocando em sua devida posição ao final do processo. O \textit{bucketsort} realiza o mesmo procedimento, exceto por manipular múltiplos números ao mesmo tempo.

\subsection{Estratégia Utilizada}

O \textit{bucketsort} adota a estratégia de dividir o intervalo $[0,1)$ em $n$ subintervalos (baldes) de igual tamanho e depois distribuir os $n$ números de entrada entre os baldes. Tendo em vista que as entradas são uniformemente distribuídas sobre $[0,1)$, não esperamos que grandes quantidade de números caiam em cada balde. Para produzir a saída, simplesmente ordenamos os números em cada balde, e depois percorremos os baldes em ordem, listando os elementos contidos em cada um \cite{cormen}.

O algoritmo \textit{bucketsort} funciona da seguinte maneira:
\begin{enumerate}
	\item Inicialize um vetor de "baldes", inicialmente vazios;
	\item Percorra o vetor original, incluindo cada elemento em um balde;
	\item \label{passo} Ordene todos os baldes não vazios;
	\item Coloque os elementos dos baldes que não estão vazios no vetor original.
\end{enumerate}

O passo \ref{passo} do funcionamento do algoritmo \textit{bucketsort} pode ser realizado de duas maneiras. A primeira é chamar recursivamente o algoritmo \textit{bucketsort} para realizar a ordenação dos baldes. A segunda maneira é utilizar qualquer outro algoritmo de ordenação para ordenar os baldes não vazios. Este artigo analisa o desempenho obtido com a utilização de subalgoritmos de ordenação para ordenar os baldes internamente.

Na análise realizada foram utilizados 4 algoritmos de ordenação diferentes. Os algoritmos escolhidos foram: \textit{insertionsort}, \textit{mergesort}, \textit{heapsort} e \textit{quicksort}.

\subsection{Pseudo-Código}

O Algoritmo~\ref{bucketsort} demonstra o pseudo-código para o algoritmo  \textit{bucketsort}. Podemos verificar que a função \textit{bucketsort} recebe como parâmetro apenas o \textit{array} a ser ordenado.

Este pseudo-código pressupõe que a entrada é um arranjo de $n$ elementos $A$, e que cada elemento $A[i]$ no arranjo satisfaz a $0 \leq A[i] \leq 1$. O código exige um \textit{array} auxiliar $B[0 .. n - 1]$ de listas ligadas (baldes) e pressupõe que existe um mecanismo para manter tais listas. 

\begin{algorithm}[H]
	\Fn{bucketsort (A[])}{
		n = comprimento[A]\;
		\For{$i = 0; i < n; i = i + 1$}{
			inserir A[i] na lista B[$\lfloor$ A[i] $\rfloor$ ]\;
		}
		\For{$i = 0; i < n - 1; i = i + 1$}{ordenar lista B[i] com qualquer algoritmo de ordenação (inclusive o próprio \textit{bucketsort})\;}
		concatenar as listas B[0], B[1], ..., B[n - 1] juntas em ordem
	}
	\KwResult{O algoritmo retorna o vetor ordenado.}
	\caption{Pseudo-código do algoritmo \textit{bucketsort}.}
	\label{bucketsort}
\end{algorithm}

O primeiro passo do Algoritmo~\ref{bucketsort} é armazenar o tamanho do \textit{array}. Logo após, um \textbf{for} percorre todo o \textit{array} $A$ e insere os elementos visitados no \textit{array} auxiliar de listas ligadas $B$.

No próximo passo, um outro \textbf{for} percorre todo o \textit{array} auxiliar de listas ligadas $B$ e aplica um algoritmo de ordenação em cada lista. Qualquer algoritmo de ordenação pode ser utilizado nessa etapa, inclusive o próprio algoritmo \textit{bucketsort} recursivamente. Para esta análise de desempenho, foram utilizados os algoritmos descritos na Seção~\ref{subalgoritmos}.

Por último, o \textit{array} auxiliar de listas ligadas $B$ é concatenado em ordem e gera como resultado os mesmos elementos do \textit{array} $A$ ordenados.

A Figura~\ref{img:bucketsort} demonstra um exemplo de funcionamento do algoritmo \textit{bucketsort} para entradas uniformemente distribuídas entre $[0,1)$. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{bucketSort.png}
	\caption{Exemplo do funcionamento do algoritmo \textit{bucketsort} utilizando dois \textit{arrays} para entradas uniformemente distribuídas.}
	\label{img:bucketsort}
\end{figure}

\subsection{Complexidade}

A complexidade do algoritmo \textit{bucketsort} depende do subalgoritmo utilizado em seu interior para realizar a ordenação das listas ligadas (baldes). 

Segundo Cormen \cite{cormen}, quando o subalgoritmo utilizado for o próprio \textit{bucketsort}, o tempo esperado a partir de uma distribuição uniforme é $\Theta(n) + n * \mathcal{O}(2-1/n) = \Theta(n)$, dessa forma, funcionando em tempo linear.

Mesmo que a entrada não seja obtida a partir de uma distribuição uniforme, o \textit{bucketsort} ainda pode ser executado em tempo linear, pois a entrada tem a propriedade de que a soma dos quadrados dos tamanhos de baldes é linear no número total de elementos.

Porém, quando outros algoritmos de ordenação forem utilizados para realizar a ordenação das listas ligadas (baldes), a complexidade do \textit{bucketsort} dependerá da complexidade do subalgoritmo utilizado.

\section{Subalgoritmos} \label{subalgoritmos}

Esta seção apresenta uma descrição geral dos subalgoritmos utilizados para realizar a análise de desempenho do algoritmo \textit{bucketsort}.

\subsection{Insertion Sort}

O \textit{insertionsort}, ou ordenação por inserção, é um simples algoritmo de ordenação, bastante eficiente quando aplicado para pequenas quantidades de elementos. Em termos gerais, ele percorre um vetor de elementos da esquerda para a direita e à medida que avança vai deixando os elementos mais à esquerda ordenados \cite{knuth}. O \textit{insertionsort} funciona da mesma maneira com que muitas pessoas ordenam cartas em um jogo de baralho, como o pôquer.

Possui o menor número de trocas e comparações entre os algoritmos de ordenação $\mathcal{O}(n)$ quando o vetor está ordenado e em seu pior caso possui complexidade de tempo $\mathcal{O}(n^2)$.

\subsection{Merge Sort}

O \textit{mergesort}, ou ordenação por mistura, é um exemplo de algoritmo de ordenação do tipo dividir-para-conquistar. Foi inventado em 1945 por John von Neumann \cite{john}.

Sua ideia básica consiste em Dividir (o problema em vários sub-problemas e resolver esses sub-problemas através de chamadas recursivas) e Conquistar (após todos os sub-problemas terem sido resolvidos ocorre a conquista que é a união das resoluções dos sub-problemas). Como o algoritmo \textit{mergesort} usa recursividade, há um alto consumo de memória e tempo de execução, tornando esta técnica não muito eficiente para alguns problemas.

Possui complexidade de tempo $\Theta (n \log_{2} n)$ e complexidade de espaço $\Theta (n)$ para todos os casos.

\subsection{Heap Sort}

O algoritmo \textit{heapsort}  é um algoritmo de ordenação generalista, e faz parte da família de algoritmos de ordenação por seleção. Foi inventado em 1964 por J.W.J Williams \cite{williams}.

O \textit{heapsort} utiliza uma estrutura de dados chamada \textit{heap}, para ordenar os elementos à medida que os insere na estrutura. Assim, ao final das inserções, os elementos podem ser sucessivamente removidos da raiz da \textit{heap}, na ordem desejada, lembrando-se sempre de manter a propriedade de \textit{max-heap}.

A \textit{heap} pode ser representada como uma árvore binária com propriedades especiais ou como um vetor \cite{baase}. Para uma ordenação decrescente, deve ser construída uma \textit{heap} mínima (o menor elemento fica na raiz). Para uma ordenação crescente, deve ser construído uma \textit{heap} máxima (o maior elemento fica na raiz).

Possui complexidade de tempo $\Theta (n \log_{2} n)$ e complexidade de espaço $\Theta (n)$ para todos os casos.

\subsection{Quick Sort}

O \textit{quicksort} é um método de ordenação muito rápido, eficiente. É um algoritmo não estável e adota a estratégia de divisão e conquista. Foi inventado em 1961 por C.A.R. Hoare \cite{hoare}.

A estratégia consiste em rearranjar as chaves de modo que chaves menores precedam chaves maiores. Em seguida o \textit{quicksort} ordena as duas sublistas de chaves menores e maiores recursivamente até que a lista completa se encontre ordenada.

Possui complexidade de tempo $\Theta (n \log_{2} n)$ e complexidade de espaço $\Theta ( \log_{2} n)$ para o melhor caso e o caso médio. Para o pior caso, possui complexidade de tempo e espaço $\Theta (n^2)$.

\section{Materiais}

Nesta seção serão apresentados os materiais utilizados para realizar as simulações propostas, tanto em termos de \textit{software}, quanto de \textit{hardware}.

\subsection{\textit{Software}}

O algoritmo \textit{bucektsort} foi implementado utilizando a linguagem de programação C. Para a compilação, foi utilizado o compilador gcc (TDM-2 mingw32) versão 4.4.1 2009 \cite{mingw}.

O ambiente de desenvolvimento integrado (IDE - \textit{Integrated Development Environment}) utilizado foi o Code::Blocks versão 13.12 \cite{codeblocks}.

O sistema operacional utilizado para realizar as simulações foi o \textit{Windows} 10 de 64 bits versão \textit{Professional} \cite{windows}. 

\subsection{\textit{Hardware}}

A máquina utilizada para realizar as simulações possui processador AMD Phenom(tm) II X4 B97 Processor 3.20 GHz com três pentes de memória RAM de 4 GB DDR3 2000Mhz, totalizando 12 GB de memória RAM.

\section{Resultados}

Para comparar os métodos, foram escolhidos dez diferentes tamanhos para o \textit{array}: 100, 500, 1.000, 5.000, 30.000, 80.000, 100.000, 150.000 e 200.000 elementos.

Para cada tamanho especificado foram gerados \textit{arrays} de números aleatórios, permitindo valores repetidos. Foram realizadas 20 simulações para cada tamanho em cada método. A média dos tempos de execuções foram utilizadas para realizar a análise comparativa.

Podemos observar na Figura~\ref{graph1} que o subalgoritmo \textit{insertionsort} apresentou os piores tempos médios de execução em relação aos outros algoritmos. Para o tamanho máximo analisado, com 200000 elementos, o algoritmo chegou a utilizar $60$ segundos em sua execução, em média.

Como os tempos médios do algoritmo \textit{insertionsort} foram bastante elevados, não foi possível identificar os tempos de execução médios dos outros subalgoritmos utilizando a Figura~\ref{graph1}. Para fins de comparação entre os métodos, todos os algoritmos, com exceção do \textit{insertionsort}, foram comparados.

Podemos observar na Figura~\ref{graph2} que os tempos médios dos algoritmos \textit{mergesort}, \textit{heapsort} e \textit{quicksort} não ultrapassaram a faixa de $0,09$ segundos. O \textit{quicksort} foi o subalgoritmo com melhores tempos médios de execução, não ultrapassando a barreira de $0,04$ segundos para todos os tamanhos de \textit{arrays} analisados.

Os algoritmos \textit{heapsort} e \textit{mergesort} ficaram com os segundos e terceiros melhores tempos médios de execução para ordenar os baldes no interior do algoritmo \textit{bucketsort}, não ultrapassando a barreira de $0,06$ e $0,08$ segundos, respectivamente.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{resultado1.png}
	\caption{Gráfico comparativo entre os tempos médios de execução dos sub-algoritmos de ordenação \textit{Insertion}, \textit{Merge}, \textit{Heap} e \textit{Quick}.}
	\label{graph1}
\end{figure}
\FloatBarrier

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{resultado2.png}
	\caption{Gráfico comparativo entre os tempos médios de execução dos sub-algoritmos de ordenação \textit{Merge}, \textit{Heap} e \textit{Quick}.}
	\label{graph2}
\end{figure}

Podemos verificar na Figura~\ref{graph2} que todos os algoritmos parecem obedecer um padrão médio de tempos de execução.

\section{Conclusão}

Podemos concluir que a escolha do subalgoritmo utilizado no interior do algoritmo de ordenação \textit{bucketsort} gera grande impacto nos tempos finais médios de execução. Portanto, quanto melhor for o desempenho do subalgoritmo de ordenação escolhido para ordenar os baldes internamentes, melhor será o desempenho geral do \textit{bucketsort}.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}