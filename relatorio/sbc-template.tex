\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage[]{algorithm2e}

\sloppy

\title{Análise de desempenho do algoritmo \textit{bucketsort} com diferentes subalgoritmos de ordenação}

\author{Eugenio Souza Carvalho\inst{1}, Hugo Santos Piauilino Neto\inst{1}}


\address{Departamento de Computação\\
	Universidade Federal do Piauí
	(UFPI)\\
	Teresina -- PI -- Brazil
	\email{\{hugos94,eugeniucarvalho\}@gmail.com}
}

\SetKwProg{Fn}{Function}{}{}

\begin{document} 

\maketitle

\begin{abstract}
	This paper presents a performance analysis of \textit{bucketsort} algorithm with different sorting subalgorithms, in addition to a general overview of the history and operation of the algorithm.
\end{abstract}

\begin{resumo} 
	Este trabalho apresenta uma análise de desempenho do algoritmo de ordenação \textit{bucketsort} com diferentes subalgoritmos de ordenação, além de apresentar um resumo geral sobre a história e funcionamento do algoritmo. 
\end{resumo}


\section{Introdução}

Problemas são questões propostas em busca de uma solução. Algoritmos são utilizados com o propósito de conceder uma solução para certo problema. Para todo problema decidível existe um algoritmo que determina uma solução para as instâncias desse problema.

Algoritmos descrevem passo a passo os procedimentos para chegar a uma solução de um problema e podem ser representados de três formas: descrição narrativa, fluxograma e a linguagem algorítmica. Neste trabalho focaremos na utilização da última forma.

Algoritmo de ordenação, em ciência da computação, é um algoritmo que coloca os elementos de uma dada sequência em uma certa ordem. Em outras palavras efetua sua ordenação completa ou parcial de acordo com uma necessidade pré-estabelecida. O objetivo da ordenação é facilitar a recuperação dos dados de uma lista.

Os mais populares algoritmos de ordenação são: \textit{insertionsort}, \textit{selectionsort}, \textit{bubblesort}, \textit{bucketsort}, \textit{quicksort}, \textit{mergesort}, \textit{heapsort} e \textit{shellsort}. Neste artigo, o algoritmo \textit{bucketsort} será analisado, explicando seu funcionamento, suas peculiaridades e seu comportamento quando os subalgoritmos \textit{insertionsort}, \textit{mergesort}, \textit{heapsort} e \textit{quicksort} são utilizados.

\section{\textit{Bucketsort}}

O \textit{bucketsort}, também conhecido como algoritmo de ordenação por baldes, funciona em tempo linear quando a entrada é gerada a partir de uma distribuição uniforme. O \textit{bucketsort} é rápido porque pressupõe  que a entrada é gerada por um processo aleatório que distribui elementos uniformementes sobre o intervalo $[0,1)$  \cite{cormen}.

\subsection{Estratégia Utilizada}

O \textit{bucketsort} adota a estratégia de dividir o intervalo $[0,1)$ em $n$ subintervalos de igual tamanho, ou \textbf{baldes}, e depois distribuir os $n$ números de entrada entre os baldes. Tendo em vista que as entradas são uniformemente distribuídas sobre $[0,1)$, não esperamos que muitos números caiam em cada balde. Para produzir a saída, simplesmente ordenamos os números em cada balde, e depois percorremos os baldes em ordem, listando os elementos contidos em cada um \cite{cormen}.

O algoritmo \textit{bucketsort} funciona do seguinte modo:
\begin{enumerate}
	\item Inicialize um vetor de "baldes", inicialmente vazios;
	\item Vá para o vetor original, incluindo cada elemento em um balde;
	\item \label{passo} Ordene todos os baldes não vazios;
	\item Coloque os elementos dos baldes que não estão vazios no vetor original.
\end{enumerate}

O passo \ref{passo} do funcionamento do algoritmo \textit{bucketsort} pode ser realizado de duas maneiras. A primeira é chamar recursivamente o algoritmo \textit{bucketsort} para realizar a ordenação dos baldes. A segunda maneira é utilizar qualquer outro algoritmo de ordenação para ordenar os baldes não vazios. Este artigo analisa o desempenho obtido com a utilização da segunda maneira.

Na análise realizada, foram utilizados 4 algoritmos de ordenação diferentes. Foram escolhidos os algoritmos: \textit{insertionsort}, \textit{mergesort}, \textit{heapsort} e \textit{quicksort}.

\subsection{Pseudo-Código}

O Algoritmo~\ref{bucketsort} demonstra o pseudo-código para o algoritmo  \textit{bucketsort}. Podemos verificar que a função \textit{bucketsort} recebe como parâmetro apenas o \textit{array} a ser ordenado. Este pseudo-código pressupõe que a entrada é um arranjo de $n$ elementos $A$, e que cada elemento $A[i]$ no arranjo satisfaz a $0 \leq A[i] \leq 1$. O código exige um \textit{array} auxiliar $B[0 .. n - 1]$ de listas ligadas (baldes) e pressupõe que existe um mecanismo para manter tais listas. 

\begin{algorithm}[H]
	\Fn{bucketsort (A[])}{
		n = comprimento[A]\;
		\For{$i = 0; i < n; i = i + 1$}{
			inserir A[i] na lista B[$\lfloor$ A[i] $\rfloor$ ]\;
		}
		\For{$i = 0; i < n - 1; i = i + 1$}{ordenar lista B[i] com qualquer algoritmo de ordenação (inclusive o próprio \textit{bucketsort})\;}
		concatenar as listas B[0], B[1], ..., B[n - 1] juntas em ordem
	}
	\KwResult{O algoritmo retorna o vetor ordenado.}
	\caption{Pseudo-código do algoritmo \textit{bucketsort}.}
	\label{bucketsort}
\end{algorithm}

O primeiro passo do Algoritmo~\ref{bucketsort} é armazenar o tamanho do \textit{array}. Logo após, um \textbf{for} percorre todo o \textit{array} $A$ e insere os elementos visitados no \textit{array} auxiliar de listas ligadas $B$.

No próximo passo, um outro \textbf{for} percorre todo o \textit{array} auxiliar de listas ligadas $B$ e aplica um algoritmo de ordenação em cada lista. Qualquer algoritmo de ordenação pode ser utilizado nessa etapa, inclusive o próprio algoritmo \textit{bucketsort} recursivamente. Para esta análise de desempenho, foram utilizados os algoritmos descritos na Seção~\ref{subalgoritmos}.

Por último, o \textit{array} auxiliar de listas ligadas $B$ é concatenado em ordem e gera como resultado os mesmos elementos do \textit{array} $A$ ordenados.

\subsection{Complexidade}

A complexidade do algoritmo \textit{bucketsort} depende do subalgoritmo utilizado em seu interior para realizar a ordenação dos baldes. 

Segundo Cormen \cite{cormen}, quando o subalgoritmo utilizado for o próprio \textit{bucketsort}, o tempo esperado a partir de uma distribuição uniforme é $\Theta(n) + n * \mathcal{O}(2-1/n) = \Theta(n)$, dessa forma, funcionando em tempo linear.

Mesmo que a entrada não seja obtida a partir de uma distribuição uniforme, o \textit{bucketsort} ainda pode ser executado em tempo linear, pois a entrada tem a propriedade de que a soma dos quadrados dos tamanhos de baldes é linear no número total de elementos.

Porém, quando outros algoritmos de ordenação forem utilizados para realizar a ordenação dos baldes, a complexidade dependerá do subalgoritmo utilizado.

\section{Subalgoritmos} \label{subalgoritmos}

Esta seção descreve os subalgoritmos utilizados para realizar a análise de desempenho do algoritmo \textit{bucketsort}.

\subsection{Insertion Sort}

O \textit{insertionsort}, ou ordenação por inserção, é um simples algoritmo de ordenação, eficiente quando aplicado a um pequeno número de elementos. Em termos gerais, ele percorre um vetor de elementos da esquerda para a direita e à medida que avança vai deixando os elementos mais à esquerda ordenados \cite{knuth}. O algoritmo de inserção funciona da mesma maneira com que muitas pessoas ordenam cartas em um jogo de baralho como o pôquer.

Possui o menor número de trocas e comparações entre os algoritmos de ordenação $\mathcal{O}(n)$ quando o vetor está ordenado e em seu pior caso possui complexidade $\mathcal{O}(n^2)$.

\subsection{Merge Sort}

O \textit{mergesort}, ou ordenação por mistura, é um exemplo de algoritmo de ordenação do tipo dividir-para-conquistar. Foi inventado em 1945 por John von Neumann \cite{john}.

Sua ideia básica consiste em Dividir (o problema em vários sub-problemas e resolver esses sub-problemas através de chamadas recursivas) e Conquistar (após todos os sub-problemas terem sido resolvidos ocorre a conquista que é a união das resoluções dos sub-problemas). Como o algoritmo \textit{mergesort} usa recursividade, há um alto consumo de memória e tempo de execução, tornando esta técnica não muito eficiente para alguns problemas.

Possui complexidade de tempo $\Theta (n \log_{2} n)$ e complexidade de espaço $\Theta (n)$ para todos os casos.

\subsection{Heap Sort}

O algoritmo \textit{heapsort}  é um algoritmo de ordenação generalista, e faz parte da família de algoritmos de ordenação por seleção. Foi inventado em 1964 por J.W.J Williams \cite{williams}.

O \textit{heapsort} utiliza uma estrutura de dados chamada \textit{heap}, para ordenar os elementos à medida que os insere na estrutura. Assim, ao final das inserções, os elementos podem ser sucessivamente removidos da raiz da \textit{heap}, na ordem desejada, lembrando-se sempre de manter a propriedade de \textit{max-heap}.

A \textit{heap} pode ser representada como uma árvore binária com propriedades especiais ou como um vetor \cite{baase}. Para uma ordenação decrescente, deve ser construída uma \textit{heap} mínima (o menor elemento fica na raiz). Para uma ordenação crescente, deve ser construído uma \textit{heap} máxima (o maior elemento fica na raiz).

Possui complexidade de tempo $\Theta (n \log_{2} n)$ e complexidade de espaço $\Theta (n)$ para todos os casos.

\subsection{Quick Sort}

O algoritmo \textit{quicksort} é um método de ordenação muito rápido e eficiente, inventado em 1961 por C.A.R. Hoare \cite{hoare}.

O \textit{quicksort} é um algoritmo de ordenação por comparação não-estável e adota a estratégia de divisão e conquista. 

A estratégia consiste em rearranjar as chaves de modo que chaves menores precedam chaves maiores. Em seguida o \textit{quicksort} ordena as duas sublistas de chaves menores e maiores recursivamente até que a lista completa se encontre ordenada.

Possui complexidade de tempo $\Theta (n \log_{2} n)$ e complexidade de espaço $\Theta ( \log_{2} n)$ para o melhor caso e o caso médio. Para o pior caso, possui complexidade de tempo e espaço $\Theta (n^2)$.

\section{Materiais}

\subsection{\textit{Software}}

O algoritmo \textit{bucektsort}foi implementado utilizando a linguagem de programação C. Para a compilação, foi utilizado o compilador gcc (TDM-2 mingw32) versão 4.4.1 2009 \cite{mingw}.

O ambiente de desenvolvimento integrado (IDE - \textit{Integrated Development Environment}) utilizado foi o Code::Blocks versão 13.12 \cite{codeblocks}.

O sistema operacional utilizado para realizar as simulações foi o \textit{Windows} 10 de 64 bits versão \textit{Professional} \cite{windows}. 

\subsection{\textit{Hardware}}

A máquina utilizada para realizar as simulações possui processador AMD Phenom(tm) II X4 B97 Processor 3.20 GHz com três pentes de memória RAM de 4 GB DDR3 2000Mhz, totalizando 12 GB de memória RAM.

\section{Resultados}

Para comparar os métodos, foram escolhidos dez diferentes tamanhos para o \textit{array}: 100, 500, 1.000, 5.000, 30.000, 80.000, 100.000, 150.000 e 200.000 elementos.

Para cada tamanho especificado foram gerados \textit{arrays} de números aleatórios, permitindo valores repetidos. Foram realizadas 20 simulações para cada tamanho em cada método. A média dos tempos de execuções foram utilizadas para realizar a análise comparativa.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{resultado1.png}
	\caption{Gráfico comparativo entre os tempo de execução dos sub-algoritmos de ordenação \textit{Insertion}, \textit{Merge}, \textit{Heap} e \textit{Quick}.}
	\label{graph1}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{resultado2.png}
	\caption{Gráfico comparativo entre os tempo de execução dos sub-algoritmos de ordenação \textit{Merge}, \textit{Heap} e \textit{Quick}.}
	\label{graph2}
\end{figure}


\section{Conclusão}

Podemos concluir que a escolha do método de particionamento tem impacto no resultado final, tal escolha deve levar em conta o tipo de entrada que será submetida ao algoritmo. Para entradas suficientemente grandes o método de particionamento de \textit{Hoare} comporta-se melhor que o método de \textit{Lomuto} obtendo menor tempo de execução.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}